---
title: 백준 2867번 수열의 값 cpp 풀이
published: 2025-09-07
description: '자료구조 / 스택'
tags: ["P.S.", "C++", "Baekjoon"]
category: 'P.S.'
draft: true
lang: 'ko'
---

## 문제

> 수열의 값이란 수열에서 가장 큰 원소와 가장 작은 원소의 차이이다.
> 
> 예를 들어, (3, 1, 7, 2)는 수열의 값이 6이고, (42, 42)는 0이다.
> 
> 수열이 주어졌을 때, 모든 부분 수열의 값의 합을 출력하는 프로그램을 작성하시오 .
> 
> (3, 1, 7, 2)의 부분 수열은 총 10개 (3), (1), (7), (2), (3,1), (1,7), (7,2), (3,1,7), (1,7,2), (3,1,7,2) 가 있고, 각각의 수열의 값을 구한뒤 이를 합하면 31이 된다.

## 문제 이해

위에서 보면 알겠지만 이 문제는 어떤 수열이 있을 때 그 수열의 부분집합 중 연속된 요소로만 이루어져있는 수열의 최댓값 - 최솟값의 합을 구하는 문제입니다.

## 첫번째 시도

이 문제를 보았을 때 바로 떠오른 건 연속된 구간을 조사해야하니 $O(N)$의 속도를 가진 슬라이딩 윈도우를 사용하려고 했습니다. 그리고 거기에 더해 구간 내 최대와 최솟값을 $O(1)$에 시간으로 알 수 있는 모노톤 큐를 이용해서 구현했습니다.

하지만 이 문제에서 주는 수열의 범위가 2~300'000이나 되어 $O(N)$의 속도로 N번 반복해서 $O(N^2)$의 속도를 가지기에 이 문제가 요구하는 1초 이내에 작동하는 것이 불가능했습니다.

```cpp
#include <bits/stdc++.h>

#define FAST_IO                   \
    ios_base::sync_with_stdio(0); \
    cin.tie(0);

using namespace std;

int N;
vector<int> arr;

int main()
{
    FAST_IO;

    cin >> N;

    arr.resize(N);

    for (int i = 0; i < N; ++i)
    {
        cin >> arr[i];
    }

    int result = 0;

    for (int i = 2; i <= N; ++i)
    {
        deque<int> inc_q;
        deque<int> dec_q;
        inc_q.push_back(0);
        dec_q.push_back(0);
        int left = 0, right = 1;
        for (; right < i; ++right)
        {
            while (!inc_q.empty() && arr[inc_q.back()] > arr[right])
                inc_q.pop_back();
            while (!dec_q.empty() && arr[dec_q.back()] < arr[right])
                dec_q.pop_back();

            inc_q.push_back(right);
            dec_q.push_back(right);
        }
        result += arr[dec_q.front()] - arr[inc_q.front()];

        while (right < N)
        {
            

            while (!inc_q.empty() && arr[inc_q.back()] > arr[right])
                inc_q.pop_back();
            while (!dec_q.empty() && arr[dec_q.back()] < arr[right])
                dec_q.pop_back();

            if (!inc_q.empty() && inc_q.front() == left) inc_q.pop_front();
            if (!dec_q.empty() && dec_q.front() == left) dec_q.pop_front();

            ++left;

            inc_q.push_back(right);
            dec_q.push_back(right);

            result += arr[dec_q.front()] - arr[inc_q.front()];

            ++right;
        }
    }

    cout << result;
}
```

## 두번째 시도